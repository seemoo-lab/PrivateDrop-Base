//
//  Signer.swift
//  PrecomputePSI
//
//  Created by Alex - SEEMOO on 23.07.20.
//

import Foundation
import Security

// swiftlint:disable force_cast
struct Signer {

    /// Path to a P12 file that containts a certificate, which is used to sign  the data
    var certificatePath: String
    /// Optional password for the file
    var certificatePassword: String?
    /// Data that should be signed
    var data: Data

    /// Generates a cryptographic message syntax (CMS) formatted output that contains the signed data and the according signatute
    ///
    /// CMS will be generated by the security framework and is compatible with PKCS7
    /// - Returns: CMS for the signed data
    func signCMS() throws -> Data {
        var encoder: CMSEncoder!
        var status = CMSEncoderCreate(&encoder)
        guard status == noErr else {
            throw NSError(
                domain: NSOSStatusErrorDomain, code: Int(status),
                userInfo: [NSLocalizedDescriptionKey: SecCopyErrorMessageString(status, nil) ?? ""])
        }

        let signingIdentity = try self.getSigningCertificate()

        CMSEncoderAddSigners(encoder, signingIdentity)

        // Add the content
        var buffer = Array(self.data)
        CMSEncoderUpdateContent(encoder, &buffer, buffer.count)

        var outputData: CFData!
        status = CMSEncoderCopyEncodedContent(encoder, &outputData)
        guard status == noErr else {
            throw NSError(
                domain: NSOSStatusErrorDomain, code: Int(status),
                userInfo: [NSLocalizedDescriptionKey: SecCopyErrorMessageString(status, nil) ?? ""])
        }

        return outputData as Data
    }

    func getSigningCertificate() throws -> SecIdentity {
        let file = try FileWrapper(url: URL(fileURLWithPath: certificatePath), options: .immediate)
        guard let certificateData = file.regularFileContents else {
            throw Error.loadingCertificateFailed
        }

        let importPassphrase = self.certificatePassword != nil ? self.certificatePassword : ""

        var identityArray: CFArray?
        let status = SecPKCS12Import(
            certificateData as CFData,
            [kSecImportExportPassphrase: importPassphrase] as CFDictionary,
            &identityArray)
        guard status == errSecSuccess,
            let identityDictionaries = identityArray as? [[CFString: Any]],
            let identityRef = identityDictionaries[0][kSecImportItemIdentity]
        else {
            throw Error.loadingCertificateFailed
        }

        let identity = identityRef as! SecIdentity

        return identity
    }

    enum Error: Swift.Error {
        case loadingCertificateFailed
    }
}
